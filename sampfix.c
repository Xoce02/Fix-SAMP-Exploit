/// Instala las bibliotecas necesarias para libpcap y firewalld con D-Bus en Ubuntu:
/// sudo apt-get install libpcap-dev libdbus-1-dev firewalld
/// Habilitar y Iniciar firewalld 
/// sudo systemctl enable firewalld
/// sudo systemctl start firewalld
/// sudo apt install gcc
/// gcc -o sampfix sampfix.c -I/usr/include/dbus-1.0 -I/usr/lib/x86_64-linux-gnu/dbus-1.0/include -lpcap -ldbus-1 
/// Si no funciona el gcc utiliza find /usr/include -name dbus.h para ver la ruta y modificalo
/// Aun esta en actualizacion

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pcap.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <arpa/inet.h>
#include <time.h>
#include <unistd.h>
#include <dbus/dbus.h>

#define BLOCK_TIME 6000 // Tiempo de bloqueo en segundos
#define MAX_BITS_OF_DATA 8192
#define MAX_DIFF 512
#define MAX_IPS 1000
#define FRAGMENT_SIZE 5 // Tamaño de cada fragmento en bytes
#define TARGET_PORT 7777 // Puerto UDP a monitorear

typedef struct {
    char ip[16];
    time_t unblock_time;
} BlockedIP;

BlockedIP blocked_ips[MAX_IPS];
int blocked_count = 0;

void block_ip(const char *ip);
int is_blocked(const char *ip);
void packet_handler(u_char *args, const struct pcap_pkthdr *header, const u_char *packet);
int get_difference_value(int value1, int value2);
void unblock_expired_ips();

int main() {
    char *dev, errbuf[PCAP_ERRBUF_SIZE];
    pcap_t *handle;

    dev = pcap_lookupdev(errbuf);
    if (dev == NULL) {
        fprintf(stderr, "No se pudo encontrar: %s\n", errbuf);
        return 1;
    }

    handle = pcap_open_live(dev, BUFSIZ, 1, 1000, errbuf);
    if (handle == NULL) {
        fprintf(stderr, "No se pudo abrir %s: %s\n", dev, errbuf);
        return 1;
    }

    while (1) {
        pcap_dispatch(handle, -1, packet_handler, NULL);
        unblock_expired_ips();
        sleep(1);
    }

    pcap_close(handle);
    return 0;
}

void block_ip(const char *ip) {
    if (blocked_count < MAX_IPS) {
        strncpy(blocked_ips[blocked_count].ip, ip, 16);
        blocked_ips[blocked_count].unblock_time = time(NULL) + BLOCK_TIME;
        blocked_count++;
        printf("IP Bloqueada: %s\n", ip);

        // Comando para bloquear IP usando firewalld (D-Bus)
        DBusConnection* conn;
        DBusMessage* msg;
        DBusError err;

        dbus_error_init(&err);
        conn = dbus_bus_get(DBUS_BUS_SYSTEM, &err);
        if (dbus_error_is_set(&err)) {
            fprintf(stderr, "Error de conexión (%s)\n", err.message);
            dbus_error_free(&err);
            return;
        }

        msg = dbus_message_new_method_call("org.fedoraproject.FirewallD1",
                                           "/org/fedoraproject/FirewallD1",
                                           "org.fedoraproject.FirewallD1.zone",
                                           "addSource");
        if (!msg) {
            fprintf(stderr, "Null\n");
            return;
        }

        const char* zone = "block";
        dbus_message_append_args(msg,
                                 DBUS_TYPE_STRING, &zone,
                                 DBUS_TYPE_STRING, &ip,
                                 DBUS_TYPE_INVALID);

        dbus_connection_send(conn, msg, NULL);
        dbus_connection_flush(conn);
        dbus_message_unref(msg);
        dbus_connection_unref(conn);
    } else {
        printf("Lista de IPs bloqueadas llena.\n");
    }
}

int is_blocked(const char *ip) {
    time_t current_time = time(NULL);
    for (int i = 0; i < blocked_count; i++) {
        if (strcmp(blocked_ips[i].ip, ip) == 0) {
            if (current_time > blocked_ips[i].unblock_time) {
                blocked_ips[i] = blocked_ips[--blocked_count];
                return 0;
            }
            return 1;
        }
    }
    return 0;
}

void packet_handler(u_char *args, const struct pcap_pkthdr *header, const u_char *packet) {
    struct ip *iph = (struct ip *)(packet + 14);
    struct udphdr *udph = (struct udphdr *)(packet + 14 + iph->ip_hl * 4);

    char ip_src[INET_ADDRSTRLEN];
    inet_ntop(AF_INET, &(iph->ip_src), ip_src, INET_ADDRSTRLEN);

    // Verificar si el paquete es UDP y si está destinado al puerto 7777
    if (iph->ip_p == IPPROTO_UDP && ntohs(udph->dest) == TARGET_PORT) {
        if (is_blocked(ip_src)) {
            printf("Paquete bloqueado de: %s\n", ip_src);
            return;
        }

        int total_len = ntohs(iph->ip_len);
        int data_len = total_len - (iph->ip_hl * 4 + sizeof(struct udphdr));

        // Fragmentar el paquete en partes más pequeñas
        int num_fragments = (data_len + FRAGMENT_SIZE - 1) / FRAGMENT_SIZE; // Redondeo hacia arriba
        for (int i = 0; i < num_fragments; ++i) {
            int start = i * FRAGMENT_SIZE;
            int end = (start + FRAGMENT_SIZE < data_len) ? start + FRAGMENT_SIZE : data_len;
            int fragment_len = end - start;

            int bits = fragment_len * 8;
            int diff = get_difference_value(bits, fragment_len);

            if (data_len > MAX_BITS_OF_DATA || diff > MAX_DIFF) {
                printf("Paquete bloqueado: IP: %s | bits usados: %d | bits asignados: %d | dif: %d\n", ip_src, fragment_len, bits, diff);
                block_ip(ip_src);
                return; // Salir después de bloquear la IP
            }
        }

        printf("Paquete aceptado: IP: %s | longitud de datos: %d | bits asignados: %d\n", ip_src, data_len, data_len * 8);
    }
}

int get_difference_value(int value1, int value2) {
    int difference = value1 - value2;
    return difference < 0 ? -difference : difference;
}

void unblock_expired_ips() {
    time_t current_time = time(NULL);
    for (int i = 0; i < blocked_count; ) {
        if (current_time > blocked_ips[i].unblock_time) {
            printf("IP Desbloqueada: %s\n", blocked_ips[i].ip);
            DBusConnection* conn;
            DBusMessage* msg;
            DBusError err;

            dbus_error_init(&err);
            conn = dbus_bus_get(DBUS_BUS_SYSTEM, &err);
            if (dbus_error_is_set(&err)) {
                fprintf(stderr, "Error de conexión (%s)\n", err.message);
                dbus_error_free(&err);
                return;
            }

            msg = dbus_message_new_method_call("org.fedoraproject.FirewallD1",
                                               "/org/fedoraproject/FirewallD1",
                                               "org.fedoraproject.FirewallD1.zone",
                                               "removeSource");
            if (!msg) {
                fprintf(stderr, "Null\n");
                return;
            }

            const char* zone = "block";
            dbus_message_append_args(msg,
                                     DBUS_TYPE_STRING, &zone,
                                     DBUS_TYPE_STRING, &blocked_ips[i].ip,
                                     DBUS_TYPE_INVALID);

            dbus_connection_send(conn, msg, NULL);
            dbus_connection_flush(conn);
            dbus_message_unref(msg);
            dbus_connection_unref(conn);

            blocked_ips[i] = blocked_ips[--blocked_count];
        } else {
            i++;
        }
    }
}
